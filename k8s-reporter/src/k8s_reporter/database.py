"""
Database client for reading k8s-analyzer SQLite databases.

This module provides a high-level interface for querying the SQLite databases
generated by k8s-analyzer, with methods optimized for web UI consumption.
"""

import json
import sqlite3
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple

import pandas as pd

from k8s_reporter.models import (
    ClusterOverview,
    ResourceSummary,
    NamespaceAnalysis,
    SecurityAnalysis,
    ResourceEfficiency,
    ComplianceReport,
)


class DatabaseClient:
    """Client for reading k8s-analyzer SQLite databases."""
    
    def __init__(self, db_path: str):
        """Initialize database client.
        
        Args:
            db_path: Path to the SQLite database file
        """
        self.db_path = Path(db_path)
        if not self.db_path.exists():
            raise FileNotFoundError(f"Database file not found: {db_path}")
    
    def get_connection(self) -> sqlite3.Connection:
        """Get database connection with row factory."""
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        return conn
    
    def get_resource_summary(self) -> ResourceSummary:
        """Get overall resource summary."""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            # Total resources and relationships
            cursor.execute("SELECT COUNT(*) FROM resources")
            total_resources = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM relationships")
            total_relationships = cursor.fetchone()[0]
            
            # Health distribution
            cursor.execute("""
                SELECT health_status, COUNT(*) as count
                FROM resources
                GROUP BY health_status
            """)
            health_distribution = {row['health_status']: row['count'] for row in cursor.fetchall()}
            
            # Resource types
            cursor.execute("""
                SELECT kind, COUNT(*) as count
                FROM resources
                GROUP BY kind
                ORDER BY count DESC
            """)
            resource_types = {row['kind']: row['count'] for row in cursor.fetchall()}
            
            # Namespaces count
            cursor.execute("""
                SELECT COUNT(DISTINCT namespace) as count
                FROM resources
                WHERE namespace IS NOT NULL
            """)
            namespaces_count = cursor.fetchone()[0]
            
            # Issues count
            cursor.execute("""
                SELECT COUNT(*) as count
                FROM resources
                WHERE issues IS NOT NULL AND issues != '[]'
            """)
            issues_count = cursor.fetchone()[0]
            
            return ResourceSummary(
                total_resources=total_resources,
                total_relationships=total_relationships,
                health_distribution=health_distribution,
                resource_types=resource_types,
                namespaces_count=namespaces_count,
                issues_count=issues_count
            )
    
    def get_cluster_overview(self) -> ClusterOverview:
        """Get high-level cluster overview."""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            # Get analysis timestamp
            cursor.execute("""
                SELECT analysis_timestamp
                FROM analysis_summary
                ORDER BY created_at DESC
                LIMIT 1
            """)
            result = cursor.fetchone()
            analysis_timestamp = datetime.fromisoformat(result[0]) if result else datetime.now()
            
            # Total resources and namespaces
            cursor.execute("SELECT COUNT(*) FROM resources")
            total_resources = cursor.fetchone()[0]
            
            cursor.execute("""
                SELECT COUNT(DISTINCT namespace)
                FROM resources
                WHERE namespace IS NOT NULL
            """)
            total_namespaces = cursor.fetchone()[0]
            
            # Health ratio
            cursor.execute("""
                SELECT 
                    SUM(CASE WHEN health_status = 'healthy' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as ratio
                FROM resources
            """)
            health_ratio = cursor.fetchone()[0] or 0.0
            
            # Top namespaces
            cursor.execute("""
                SELECT namespace, COUNT(*) as count
                FROM resources
                WHERE namespace IS NOT NULL
                GROUP BY namespace
                ORDER BY count DESC
                LIMIT 10
            """)
            top_namespaces = [{"name": row['namespace'], "count": row['count']} for row in cursor.fetchall()]
            
            # Resource distribution
            cursor.execute("""
                SELECT kind, COUNT(*) as count
                FROM resources
                GROUP BY kind
                ORDER BY count DESC
            """)
            resource_distribution = {row['kind']: row['count'] for row in cursor.fetchall()}
            
            # Issues summary
            cursor.execute("""
                SELECT health_status, COUNT(*) as count
                FROM resources
                WHERE health_status != 'healthy'
                GROUP BY health_status
            """)
            issues_summary = {row['health_status']: row['count'] for row in cursor.fetchall()}
            
            return ClusterOverview(
                analysis_timestamp=analysis_timestamp,
                total_resources=total_resources,
                total_namespaces=total_namespaces,
                health_ratio=health_ratio,
                top_namespaces=top_namespaces,
                resource_distribution=resource_distribution,
                issues_summary=issues_summary
            )
    
    def get_namespace_analysis(self, namespace: str) -> Optional[NamespaceAnalysis]:
        """Get detailed analysis for a specific namespace."""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            # Check if namespace exists
            cursor.execute("SELECT COUNT(*) FROM resources WHERE namespace = ?", (namespace,))
            if cursor.fetchone()[0] == 0:
                return None
            
            # Resource count
            cursor.execute("SELECT COUNT(*) FROM resources WHERE namespace = ?", (namespace,))
            resource_count = cursor.fetchone()[0]
            
            # Resource types
            cursor.execute("""
                SELECT kind, COUNT(*) as count
                FROM resources
                WHERE namespace = ?
                GROUP BY kind
                ORDER BY count DESC
            """, (namespace,))
            resource_types = {row['kind']: row['count'] for row in cursor.fetchall()}
            
            # Health distribution
            cursor.execute("""
                SELECT health_status, COUNT(*) as count
                FROM resources
                WHERE namespace = ?
                GROUP BY health_status
            """, (namespace,))
            health_distribution = {row['health_status']: row['count'] for row in cursor.fetchall()}
            
            # Issues count
            cursor.execute("""
                SELECT COUNT(*) as count
                FROM resources
                WHERE namespace = ? AND issues IS NOT NULL AND issues != '[]'
            """, (namespace,))
            issues_count = cursor.fetchone()[0]
            
            # Relationships count
            cursor.execute("""
                SELECT COUNT(*) as count
                FROM relationships
                WHERE source_namespace = ? OR target_namespace = ?
            """, (namespace, namespace))
            relationships_count = cursor.fetchone()[0]
            
            # Top resources
            cursor.execute("""
                SELECT name, kind, health_status
                FROM resources
                WHERE namespace = ?
                ORDER BY 
                    CASE health_status 
                        WHEN 'error' THEN 1 
                        WHEN 'warning' THEN 2 
                        ELSE 3 
                    END,
                    name
                LIMIT 10
            """, (namespace,))
            top_resources = [
                {"name": row['name'], "kind": row['kind'], "health": row['health_status']}
                for row in cursor.fetchall()
            ]
            
            return NamespaceAnalysis(
                name=namespace,
                resource_count=resource_count,
                resource_types=resource_types,
                health_distribution=health_distribution,
                issues_count=issues_count,
                relationships_count=relationships_count,
                top_resources=top_resources
            )
    
    def get_security_analysis(self) -> SecurityAnalysis:
        """Get security-focused analysis."""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            # Service accounts
            cursor.execute("SELECT COUNT(*) FROM resources WHERE kind = 'ServiceAccount'")
            service_accounts_count = cursor.fetchone()[0]
            
            # Role bindings
            cursor.execute("SELECT COUNT(*) FROM resources WHERE kind = 'RoleBinding'")
            role_bindings_count = cursor.fetchone()[0]
            
            # ConfigMaps and Secrets (approximation)
            cursor.execute("SELECT COUNT(*) FROM resources WHERE kind = 'ConfigMap'")
            config_maps_count = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM resources WHERE kind = 'Secret'")
            secrets_count = cursor.fetchone()[0]
            
            # For pods analysis, we need to parse the spec JSON
            cursor.execute("""
                SELECT spec
                FROM resources
                WHERE kind = 'Pod' AND spec IS NOT NULL
            """)
            
            privileged_pods = 0
            pods_without_security_context = 0
            root_containers = 0
            
            for row in cursor.fetchall():
                try:
                    spec = json.loads(row['spec'])
                    containers = spec.get('containers', [])
                    
                    has_security_context = False
                    for container in containers:
                        security_context = container.get('securityContext', {})
                        if security_context:
                            has_security_context = True
                            if security_context.get('privileged', False):
                                privileged_pods += 1
                            if security_context.get('runAsUser') == 0:
                                root_containers += 1
                    
                    if not has_security_context:
                        pods_without_security_context += 1
                        
                except (json.JSONDecodeError, KeyError):
                    continue
            
            return SecurityAnalysis(
                privileged_pods=privileged_pods,
                pods_without_security_context=pods_without_security_context,
                root_containers=root_containers,
                service_accounts_count=service_accounts_count,
                role_bindings_count=role_bindings_count,
                cluster_role_bindings=0,  # Not available in current schema
                secrets_count=secrets_count,
                config_maps_count=config_maps_count
            )
    
    def get_resources_dataframe(self, filters: Optional[Dict[str, Any]] = None) -> pd.DataFrame:
        """Get resources as pandas DataFrame for analysis."""
        query = "SELECT * FROM resources WHERE 1=1"
        params = []
        
        if filters:
            if filters.get('namespace'):
                query += " AND namespace = ?"
                params.append(filters['namespace'])
            if filters.get('kind'):
                query += " AND kind = ?"
                params.append(filters['kind'])
            if filters.get('health_status'):
                query += " AND health_status = ?"
                params.append(filters['health_status'])
        
        with self.get_connection() as conn:
            return pd.read_sql_query(query, conn, params=params)
    
    def get_relationships_dataframe(self, filters: Optional[Dict[str, Any]] = None) -> pd.DataFrame:
        """Get relationships as pandas DataFrame for analysis."""
        query = "SELECT * FROM relationships WHERE 1=1"
        params = []
        
        if filters:
            if filters.get('source_namespace'):
                query += " AND source_namespace = ?"
                params.append(filters['source_namespace'])
            if filters.get('relationship_type'):
                query += " AND relationship_type = ?"
                params.append(filters['relationship_type'])
        
        with self.get_connection() as conn:
            return pd.read_sql_query(query, conn, params=params)
    
    def get_namespaces(self) -> List[str]:
        """Get list of all namespaces."""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT DISTINCT namespace
                FROM resources
                WHERE namespace IS NOT NULL
                ORDER BY namespace
            """)
            return [row[0] for row in cursor.fetchall()]
    
    def get_resource_kinds(self) -> List[str]:
        """Get list of all resource kinds."""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT DISTINCT kind
                FROM resources
                ORDER BY kind
            """)
            return [row[0] for row in cursor.fetchall()]
    
    def get_health_over_time(self) -> pd.DataFrame:
        """Get health status changes over time."""
        with self.get_connection() as conn:
            query = """
                SELECT 
                    DATE(timestamp) as date,
                    health_status,
                    COUNT(*) as count
                FROM resource_health_history
                GROUP BY DATE(timestamp), health_status
                ORDER BY date
            """
            return pd.read_sql_query(query, conn)
    
    def search_resources(self, search_term: str, limit: int = 50) -> List[Dict[str, Any]]:
        """Search resources by name or kind."""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT name, namespace, kind, health_status, uid
                FROM resources
                WHERE name LIKE ? OR kind LIKE ?
                ORDER BY 
                    CASE health_status 
                        WHEN 'error' THEN 1 
                        WHEN 'warning' THEN 2 
                        ELSE 3 
                    END,
                    name
                LIMIT ?
            """, (f"%{search_term}%", f"%{search_term}%", limit))
            
            return [dict(row) for row in cursor.fetchall()]
